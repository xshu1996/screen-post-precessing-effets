{
  "ver": "1.0.27",
  "uuid": "3ce68cbc-3334-4b8f-a00a-62ee51d89e51",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform vec4 cc_time;\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if USE_STRIP_NOISE_TEXTURE\nuniform sampler2D stripNoiseTex;\nuniform vec4 stripColorAdjustColor;\n#endif\nuniform vec4 UVoffset;\nuniform float rotated;\nuniform float intensity;\nfloat randomNoise2(vec2 seed)\n{\n  float speed = 10.0;\n  return fract(sin(dot(seed * floor(cc_time.x * speed), vec2(17.13, 3.71))) * 43758.5453123);\n}\nfloat trunc(float x, float num_levels)\n{\n  return floor(x * num_levels) / num_levels;\n}\nvec2 trunc2(vec2 x, vec2 num_levels)\n{\n  return floor(x * num_levels) / num_levels;\n}\nvec3 rgb2yuv(vec3 rgb)\n{\n  vec3 yuv;\n  yuv.x = dot(rgb, vec3(0.299, 0.587, 0.114));\n  yuv.y = dot(rgb, vec3(-0.14713, -0.28886, 0.436));\n  yuv.z = dot(rgb, vec3(0.615, -0.51499, -0.10001));\n  return yuv;\n}\nvec3 yuv2rgb(vec3 yuv)\n{\n  vec3 rgb;\n  rgb.r = yuv.x + yuv.z * 1.13983;\n  rgb.g = yuv.x + dot(vec2(-0.39465, -0.58060), yuv.yz);\n  rgb.b = yuv.x + yuv.y * 2.03211;\n  return rgb;\n}\nvec4 lineBlockGlitchHorizontal(vec2 uv) {\n  float _LinesWidth = 1.0;\n  float _Amount = 0.5;\n  float _Speed = 1.0;\n  float _Offset = 1.0;\n  float _Alpha = 1.0;\n  float strength = 10.0;\n  float _TimeX = cc_time.x;\n  strength = 0.5 + 0.5 * cos(_TimeX * 100.0);\n  _TimeX *= strength;\n  float truncTime = trunc(_TimeX, 4.0);\n  float uv_trunc = randomNoise2(trunc2(vec2(uv.y), vec2(8.0, 8.0)) + 100.0 * truncTime);\n  float uv_randomTrunc = 6.0 * trunc(_TimeX, 24.0 * uv_trunc);\n  float blockLine_random = 0.5 * randomNoise2(trunc2(vec2(uv.y) + uv_randomTrunc, vec2(8.0 * _LinesWidth, 8.0 * _LinesWidth)));\n  blockLine_random += 0.5 * randomNoise2(trunc2(vec2(uv.y) + uv_randomTrunc, vec2(7.0, 7.0)));\n  blockLine_random = blockLine_random * 2.0 - 1.0;\n  blockLine_random = sign(blockLine_random) * clamp((abs(blockLine_random) - _Amount) / (0.4), 0.0, 1.0);\n  blockLine_random = mix(0.0, blockLine_random, _Offset);\n  vec2 uv_blockLine = uv;\n  uv_blockLine = clamp(uv_blockLine + vec2(0, 0.1 * blockLine_random), vec2(0.), vec2(1.));\n  vec4 blockLineColor = texture2D(texture, abs(uv_blockLine));\n  vec3 blockLineColor_yuv = rgb2yuv(blockLineColor.rgb);\n  blockLineColor_yuv.y /= 1.0 - 3.0 * abs(blockLine_random) * clamp(0.5 - blockLine_random, 0.0, 1.0);\n  blockLineColor_yuv.z += 0.125 * blockLine_random * clamp(blockLine_random - 0.5, 0.0, 1.0);\n  vec3 blockLineColor_rgb = yuv2rgb(blockLineColor_yuv);\n  vec4 sceneColor = texture2D(texture, uv);\n  return mix(sceneColor, vec4(blockLineColor_rgb, blockLineColor.a), _Alpha);\n}\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  float time = cc_time.x;\n  vec2 normalizedUV;\n  normalizedUV.x = (v_uv0.x - UVoffset.x) / (UVoffset.z - UVoffset.x);\n  normalizedUV.y = (v_uv0.y - UVoffset.y) / (UVoffset.w - UVoffset.y);\n  if (rotated > 0.5) {\n    float temp = normalizedUV.x;\n    normalizedUV.x = normalizedUV.y;\n    normalizedUV.y = 1.0 - temp;\n  }\n  #if USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n  #endif\n  #if USE_STRIP_NOISE_TEXTURE\n    vec2 uv = normalizedUV;\n    vec4 stripNoise = texture2D(stripNoiseTex, uv);\n    float threshold = 1.001 - intensity * 1.001;\n    float uvShift = step(threshold, pow(abs(stripNoise.x), 3.0));\n    uv = fract(uv + stripNoise.yz * uvShift);\n    vec4 source = texture2D(texture, uv);\n    float stripIntensity = step(threshold, pow(abs(stripNoise.w), 3.0)) * 2.0;\n    vec3 color = mix(source, stripColorAdjustColor, stripIntensity).rgb;\n    o = vec4(color, source.a);\n    o = source;\n  #else\n    o = lineBlockGlitchHorizontal(normalizedUV);\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_BGRA\n    gl_FragColor = o.bgra;\n  #else\n    gl_FragColor = o.rgba;\n  #endif\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if USE_STRIP_NOISE_TEXTURE\nuniform sampler2D stripNoiseTex;\nuniform stripParam {\n  vec4 stripColorAdjustColor;\n};\n#endif\nuniform Constant {\n  vec4 UVoffset;\n  float rotated;\n  float intensity;\n};\nfloat randomNoise2(vec2 seed)\n{\n  float speed = 10.0;\n  return fract(sin(dot(seed * floor(cc_time.x * speed), vec2(17.13, 3.71))) * 43758.5453123);\n}\nfloat trunc(float x, float num_levels)\n{\n  return floor(x * num_levels) / num_levels;\n}\nvec2 trunc2(vec2 x, vec2 num_levels)\n{\n  return floor(x * num_levels) / num_levels;\n}\nvec3 rgb2yuv(vec3 rgb)\n{\n  vec3 yuv;\n  yuv.x = dot(rgb, vec3(0.299, 0.587, 0.114));\n  yuv.y = dot(rgb, vec3(-0.14713, -0.28886, 0.436));\n  yuv.z = dot(rgb, vec3(0.615, -0.51499, -0.10001));\n  return yuv;\n}\nvec3 yuv2rgb(vec3 yuv)\n{\n  vec3 rgb;\n  rgb.r = yuv.x + yuv.z * 1.13983;\n  rgb.g = yuv.x + dot(vec2(-0.39465, -0.58060), yuv.yz);\n  rgb.b = yuv.x + yuv.y * 2.03211;\n  return rgb;\n}\nvec4 lineBlockGlitchHorizontal(vec2 uv) {\n  float _LinesWidth = 1.0;\n  float _Amount = 0.5;\n  float _Speed = 1.0;\n  float _Offset = 1.0;\n  float _Alpha = 1.0;\n  float strength = 10.0;\n  float _TimeX = cc_time.x;\n  strength = 0.5 + 0.5 * cos(_TimeX * 100.0);\n  _TimeX *= strength;\n  float truncTime = trunc(_TimeX, 4.0);\n  float uv_trunc = randomNoise2(trunc2(vec2(uv.y), vec2(8.0, 8.0)) + 100.0 * truncTime);\n  float uv_randomTrunc = 6.0 * trunc(_TimeX, 24.0 * uv_trunc);\n  float blockLine_random = 0.5 * randomNoise2(trunc2(vec2(uv.y) + uv_randomTrunc, vec2(8.0 * _LinesWidth, 8.0 * _LinesWidth)));\n  blockLine_random += 0.5 * randomNoise2(trunc2(vec2(uv.y) + uv_randomTrunc, vec2(7.0, 7.0)));\n  blockLine_random = blockLine_random * 2.0 - 1.0;\n  blockLine_random = sign(blockLine_random) * clamp((abs(blockLine_random) - _Amount) / (0.4), 0.0, 1.0);\n  blockLine_random = mix(0.0, blockLine_random, _Offset);\n  vec2 uv_blockLine = uv;\n  uv_blockLine = clamp(uv_blockLine + vec2(0, 0.1 * blockLine_random), vec2(0.), vec2(1.));\n  vec4 blockLineColor = texture(texture, abs(uv_blockLine));\n  vec3 blockLineColor_yuv = rgb2yuv(blockLineColor.rgb);\n  blockLineColor_yuv.y /= 1.0 - 3.0 * abs(blockLine_random) * clamp(0.5 - blockLine_random, 0.0, 1.0);\n  blockLineColor_yuv.z += 0.125 * blockLine_random * clamp(blockLine_random - 0.5, 0.0, 1.0);\n  vec3 blockLineColor_rgb = yuv2rgb(blockLineColor_yuv);\n  vec4 sceneColor = texture(texture, uv);\n  return mix(sceneColor, vec4(blockLineColor_rgb, blockLineColor.a), _Alpha);\n}\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  float time = cc_time.x;\n  vec2 normalizedUV;\n  normalizedUV.x = (v_uv0.x - UVoffset.x) / (UVoffset.z - UVoffset.x);\n  normalizedUV.y = (v_uv0.y - UVoffset.y) / (UVoffset.w - UVoffset.y);\n  if (rotated > 0.5) {\n    float temp = normalizedUV.x;\n    normalizedUV.x = normalizedUV.y;\n    normalizedUV.y = 1.0 - temp;\n  }\n  #if USE_TEXTURE\n  vec4 texture_tmp = texture(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n  #endif\n  #if USE_STRIP_NOISE_TEXTURE\n    vec2 uv = normalizedUV;\n    vec4 stripNoise = texture(stripNoiseTex, uv);\n    float threshold = 1.001 - intensity * 1.001;\n    float uvShift = step(threshold, pow(abs(stripNoise.x), 3.0));\n    uv = fract(uv + stripNoise.yz * uvShift);\n    vec4 source = texture(texture, uv);\n    float stripIntensity = step(threshold, pow(abs(stripNoise.w), 3.0)) * 2.0;\n    vec3 color = mix(source, stripColorAdjustColor, stripIntensity).rgb;\n    o = vec4(color, source.a);\n    o = source;\n  #else\n    o = lineBlockGlitchHorizontal(normalizedUV);\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_BGRA\n    gl_FragColor = o.bgra;\n  #else\n    gl_FragColor = o.rgba;\n  #endif\n}"
      }
    }
  ],
  "subMetas": {}
}